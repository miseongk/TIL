# 프록시

- `em.find()`: 데이터베이스를 통해서 실제 엔티티 객체 조회
- `em.getReference()`: 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

## 프록시 특징

- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨
- 프록시 객체는 실제 객체의 참조(target)를 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

```java
Member member = em.getReference(Member.class, "id1"); // (1)
member.getName(); // (2)
```

(1)에서는 프록시 member 객체를 전달

(2)에서 `getName()` 호출 시 다음과 같은 과정 진행

1. MemberProxy 객체의 Member 객체에 데이터가 없음
2. 영속성 컨텍스트에 초기화 요청
3. DB 조회해서 실제 엔티티 생성
4. `target.getName()`으로 진짜 객체를 연결해줌

- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크 시 주의해야함 ( == 비교 불가, `instance of` 사용)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 실제 엔티티가 반환됨
  - 이미 있는데 굳이 데이터베이스에서 가져올 필요가 없음
  - JPA에서는 동일성을 보장하기 때문에 다른 타입의 클래스를 가져오면 안됨 ( == 비교 시 true를 반환해야 하기 때문)
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생 (LazyInitializationException 발생)

---

# 지연 로딩과 즉시 로딩

## 지연 로딩 LAZY를 사용해서 프록시로 조회

`fetch = FetchType.LAZY`

실제 엔티티를 사용하는 시점에 초기화(DB 조회)

_Member가 Team을 가지고 있을 때, Member 조회 시 Team은 프록시로 조회_

## 즉시 로딩 EAGER를 사용해서 함께 조회

만약 대부분 Member 조회 시 Team도 함께 조회한다면?

`fetch = FetchType.EAGER`

_Member가 Team을 가지고 있을 때, Member 조회 시 Team도 즉시 조회해서 가져옴_

## 프록시와 즉시 로딩 주의

- **가급적 지연 로딩만 사용!!!!! ⭐️**
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
- 즉시 로딩은 JPQL에서 **N+1 문제**를 일으킨다.
- **@ManyToOne, @OneToOne은 즉시 로딩이 기본 → LAZY로 설정**
- @OneToMany, @ManyToMany는 지연 로딩이 기본
